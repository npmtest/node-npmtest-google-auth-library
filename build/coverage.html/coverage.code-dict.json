{"/home/travis/build/npmtest/node-npmtest-google-auth-library/test.js":"/* istanbul instrument in package npmtest_google_auth_library */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-google-auth-library/lib.npmtest_google_auth_library.js":"/* istanbul instrument in package npmtest_google_auth_library */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_google_auth_library = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_google_auth_library = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-google-auth-library/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-google-auth-library && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_google_auth_library */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_google_auth_library\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_google_auth_library.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_google_auth_library.rollup.js'] =\n            local.assetsDict['/assets.npmtest_google_auth_library.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_google_auth_library.__dirname + '/lib.npmtest_google_auth_library.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-google-auth-library/node_modules/google-auth-library/lib/auth/googleauth.js":"/**\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nvar JWTClient = require('./jwtclient.js');\nvar ComputeClient = require('./computeclient.js');\nvar exec = require('child_process').exec;\nvar fs = require('fs');\nvar os = require('os');\nvar path = require('path');\nvar util = require('util');\nvar DefaultTransporter = require('../transporters.js');\n\n/**\n * GoogleAuth account manager.\n *\n * @constructor\n */\nfunction GoogleAuth() {\n  this.JWTClient = JWTClient;\n  this.ComputeClient = ComputeClient;\n  this._cachedCredential = null;\n}\n\n// Executes the given callback if it is not null.\nfunction callback(c) {\n  if (c) {\n    return c.apply(null, Array.prototype.slice.call(arguments, 1));\n  }\n}\n\n// Creates an Error containing the given message, and includes the message from the optional err\n// passed in.\nfunction createError(message, err) {\n  var s = message || '';\n  if (err) {\n    var errorMessage = String(err);\n    if (errorMessage && errorMessage.length > 0) {\n      if (s.length > 0) {\n        s += ' ';\n      }\n      s += errorMessage;\n    }\n  }\n  return Error(s);\n}\n\n/**\n * Convenience field mapping in the IAM credential type.\n */\nGoogleAuth.prototype.IAMAuth = require('./iam.js');\n\n/**\n * Convenience field mapping in the Compute credential type.\n */\nGoogleAuth.prototype.Compute = require('./computeclient.js');\n\n/**\n * Convenience field mapping in the JWT credential type.\n */\nGoogleAuth.prototype.JWT = require('./jwtclient.js');\n\n/**\n * Convenience field mapping in the JWT Access credential type.\n */\nGoogleAuth.prototype.JWTAccess = require('./jwtaccess.js');\n\n/**\n * Convenience field mapping in the OAuth2 credential type.\n */\nGoogleAuth.prototype.OAuth2 = require('./oauth2client.js');\n\n/**\n * Convenience field mapping to the UserRefreshClient credential type.\n */\nGoogleAuth.prototype.UserRefreshClient = require('./refreshclient.js');\n\n/**\n * Caches a value indicating whether the auth layer is running on Google Compute Engine.\n * @private\n */\nGoogleAuth.prototype._isGCE = false;\n\n/**\n * Caches a value indicating whether we've checked whether the auth layer is running on\n * Google Compute Engine.\n * @private\n */\nGoogleAuth.prototype._checked_isGCE = false;\n\n/**\n * Obtains the default project ID for the application..\n * @param {function=} opt_callback Optional callback.\n */\nGoogleAuth.prototype.getDefaultProjectId = function(opt_callback) {\n  var that = this;\n\n  // In implicit case, supports three environments. In order of precedence, the\n  // implicit environments are:\n  //\n  // * GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n  // * GOOGLE_APPLICATION_CREDENTIALS JSON file\n  // * Get default service project from\n  //  ``$ gcloud beta auth application-default login``\n  // * Google App Engine application ID (Not implemented yet)\n  // * Google Compute Engine project ID (from metadata server) (Not implemented yet)\n\n  if (that._cachedProjectId) {\n    process.nextTick(function() {\n      callback(opt_callback, null, that._cachedProjectId);\n    });\n  } else {\n    var my_callback = function(err, projectId) {\n      if (!err && projectId) {\n        that._cachedprojectId = projectId;\n      }\n      process.nextTick(function() {\n        callback(opt_callback, err, projectId);\n      });\n    };\n\n    // environment variable\n    if (that._getProductionProjectId(my_callback)) {\n      return;\n    }\n\n    // json file\n    that._getFileProjectId(function(err, projectId) {\n      if (err || projectId) {\n        my_callback(err, projectId);\n        return;\n      }\n\n      // Google Cloud SDK default project id\n      that._getDefaultServiceProjectId(function(err, projectId) {\n        if (err || projectId) {\n          my_callback(err, projectId);\n          return;\n        }\n\n        // Get project ID from Compute Engine metadata server\n        that._getGCEProjectId(my_callback);\n      });\n    });\n  }\n};\n\n/**\n * Loads the project id from environment variables.\n * @param {function} _callback Callback.\n * @api private\n */\nGoogleAuth.prototype._getProductionProjectId = function(_callback) {\n  var projectId = this._getEnv('GCLOUD_PROJECT') || this._getEnv('GOOGLE_CLOUD_PROJECT');\n  if (projectId) {\n    process.nextTick(function() {\n      callback(_callback, null, projectId);\n    });\n  }\n  return projectId;\n};\n\n/**\n * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n * @param {function} _callback Callback.\n * @api private\n */\nGoogleAuth.prototype._getFileProjectId = function(_callback) {\n  var that = this;\n  if (that._cachedCredential) {\n    // Try to read the project ID from the cached credentials file\n    process.nextTick(function() {\n      callback(_callback, null, that._cachedCredential.projectId);\n    });\n    return;\n  }\n\n  // Try to load a credentials file and read its project ID\n  var pathExists = that._tryGetApplicationCredentialsFromEnvironmentVariable(function(err, result) {\n    if (!err && result) {\n      callback(_callback, null, result.projectId);\n      return;\n    }\n    callback(_callback, err);\n  });\n\n  if (!pathExists) {\n    callback(_callback, null);\n  }\n};\n\n/**\n * Loads the default project of the Google Cloud SDK.\n * @param {function} _callback Callback.\n * @api private\n */\nGoogleAuth.prototype._getDefaultServiceProjectId = function(_callback) {\n  this._getSDKDefaultProjectId(function(err, stdout) {\n    var projectId;\n    if (!err && stdout) {\n      try {\n        projectId = JSON.parse(stdout).core.project;\n      } catch (err) {\n        projectId = null;\n      }\n    }\n    // Ignore any errors\n    callback(_callback, null, projectId);\n  });\n};\n\n/**\n * Run the Google Cloud SDK command that prints the default project ID\n * @param {function} _callback Callback.\n * @api private\n */\nGoogleAuth.prototype._getSDKDefaultProjectId = function(_callback) {\n  exec('gcloud -q config list core/project --format=json', _callback);\n};\n\n/**\n * Gets the Compute Engine project ID if it can be inferred.\n * Uses 169.254.169.254 for the metadata server to avoid request\n * latency from DNS lookup.\n * See https://cloud.google.com/compute/docs/metadata#metadataserver\n * for information about this IP address. (This IP is also used for\n * Amazon EC2 instances, so the metadata flavor is crucial.)\n * See https://github.com/google/oauth2client/issues/93 for context about\n * DNS latency.\n *\n * @param {function} _callback Callback.\n * @api private\n */\nGoogleAuth.prototype._getGCEProjectId = function(_callback) {\n  if (!this.transporter) {\n    this.transporter = new DefaultTransporter();\n  }\n  this.transporter.request({\n    method: 'GET',\n    uri: 'http://169.254.169.254/computeMetadata/v1/project/project-id',\n    headers: {\n      'Metadata-Flavor': 'Google'\n    }\n  }, function(err, body, res) {\n    if (err || !res || res.statusCode !== 200 || !body) {\n      callback(_callback, null);\n      return;\n    }\n    // Ignore any errors\n    callback(_callback, null, body);\n  });\n};\n\n/**\n * Obtains the default service-level credentials for the application..\n * @param {function=} opt_callback Optional callback.\n */\nGoogleAuth.prototype.getApplicationDefault = function(opt_callback) {\n  var that = this;\n\n  // If we've already got a cached credential, just return it.\n  if (that._cachedCredential) {\n    process.nextTick(function() {\n      callback(opt_callback, null, that._cachedCredential, that._cachedProjectId);\n    });\n  } else {\n    // Inject our own callback routine, which will cache the credential once it's been created.\n    // It also allows us to ensure that the ultimate callback is always async.\n    var my_callback = function(err, result) {\n      if (!err && result) {\n        that._cachedCredential = result;\n        that.getDefaultProjectId(function(err, projectId) {\n          process.nextTick(function() {\n            // Ignore default project error\n            callback(opt_callback, null, result, projectId);\n          });\n        });\n      } else {\n        process.nextTick(function() {\n          callback(opt_callback, err, result);\n        });\n      }\n    };\n    // Check for the existence of a local environment variable pointing to the\n    // location of the credential file. This is typically used in local developer scenarios.\n    if (that._tryGetApplicationCredentialsFromEnvironmentVariable(my_callback)) {\n      return;\n    }\n\n    // Look in the well-known credential file location.\n    if (that._tryGetApplicationCredentialsFromWellKnownFile(my_callback)) {\n      return;\n    }\n\n    // Determine if we're running on GCE.\n    that._checkIsGCE(function(gce) {\n      if (gce) {\n        // For GCE, just return a default ComputeClient. It will take care of the rest.\n        my_callback(null, new that.ComputeClient());\n      } else {\n        // We failed to find the default credentials. Bail out with an error.\n        my_callback(new Error('Could not load the default credentials. Browse to ' +\n          'https://developers.google.com/accounts/docs/application-default-credentials for ' +\n          'more information.'));\n      }\n    });\n  }\n};\n\n/**\n * Determines whether the auth layer is running on Google Compute Engine.\n * @param {function=} callback The callback.\n * @api private\n */\nGoogleAuth.prototype._checkIsGCE = function(callback) {\n  var that = this;\n  if (that._checked_isGCE) {\n    callback(that._isGCE);\n  } else {\n    if (!that.transporter) {\n      that.transporter = new DefaultTransporter();\n    }\n    that.transporter.request({\n      method: 'GET',\n      uri: 'http://metadata.google.internal',\n      json: true\n    }, function(err, body, res) {\n      if (!err && res && res.headers) {\n        that._isGCE = res.headers['metadata-flavor'] === 'Google';\n      }\n      that._checked_isGCE = true;\n      callback(that._isGCE);\n    });\n  }\n};\n\n/**\n * Attempts to load default credentials from the environment variable path..\n * @param {function=} opt_callback Optional callback.\n * @return {boolean} Returns true if the callback has been executed; false otherwise.\n * @api private\n */\nGoogleAuth.prototype._tryGetApplicationCredentialsFromEnvironmentVariable =\n  function(opt_callback) {\n\n    var that = this;\n    var credentialsPath = that._getEnv('GOOGLE_APPLICATION_CREDENTIALS');\n    if (!credentialsPath || credentialsPath.length === 0) {\n      return false;\n    }\n    that._getApplicationCredentialsFromFilePath(credentialsPath, function(err, result) {\n      var wrappedError = null;\n      if (err) {\n        wrappedError = createError(\n            'Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS ' +\n            'environment variable.',\n          err);\n      }\n      callback(opt_callback, wrappedError, result);\n    });\n    return true;\n  };\n\n/**\n * Attempts to load default credentials from a well-known file location\n * @param {function=} opt_callback Optional callback.\n * @return {boolean} Returns true if the callback has been executed; false otherwise.\n * @api private\n */\nGoogleAuth.prototype._tryGetApplicationCredentialsFromWellKnownFile =\n  function(opt_callback) {\n\n    var that = this;\n    // First, figure out the location of the file, depending upon the OS type.\n    var location = null;\n    if (that._isWindows()) {\n      // Windows\n      location = that._getEnv('APPDATA');\n    } else {\n      // Linux or Mac\n      var home = that._getEnv('HOME');\n      if (home) {\n        location = that._pathJoin(home, '.config');\n      }\n    }\n    // If we found the root path, expand it.\n    if (location) {\n      location = that._pathJoin(location, 'gcloud');\n      location = that._pathJoin(location, 'application_default_credentials.json');\n      location = that._mockWellKnownFilePath(location);\n      // Check whether the file exists.\n      if (!that._fileExists(location)) {\n        location = null;\n      }\n    }\n    // The file does not exist.\n    if (!location) {\n      return false;\n    }\n    // The file seems to exist. Try to use it.\n    this._getApplicationCredentialsFromFilePath(location, opt_callback);\n    return true;\n  };\n\n/**\n * Attempts to load default credentials from a file at the given path..\n * @param {string=} filePath The path to the file to read.\n * @param {function=} opt_callback Optional callback.\n * @api private\n */\nGoogleAuth.prototype._getApplicationCredentialsFromFilePath =\n  function(filePath, opt_callback) {\n\n    var that = this;\n    var error = null;\n    // Make sure the path looks like a string.\n    if (!filePath || filePath.length === 0) {\n      error = new Error('The file path is invalid.');\n    }\n\n    // Make sure there is a file at the path. lstatSync will throw if there is nothing there.\n    if (!error) {\n      try {\n        // Resolve path to actual file in case of symlink. Expect a thrown error if not resolvable.\n        filePath = fs.realpathSync(filePath);\n\n        if (!fs.lstatSync(filePath).isFile()) {\n          throw '';\n        }\n      } catch (err) {\n        error = createError(util.format('The file at %s does not exist, or it is not a file.',\n          filePath), err);\n      }\n    }\n    // Now open a read stream on the file, and parse it.\n    if (!error) {\n      try {\n        var stream = that._createReadStream(filePath);\n        that.fromStream(stream, opt_callback);\n      } catch (err) {\n        error = createError(util.format('Unable to read the file at %s.', filePath), err);\n      }\n    }\n    if (error) {\n      callback(opt_callback, error);\n    }\n  };\n\n/**\n * Create a credentials instance using the given input options.\n * @param {object=} json The input object.\n * @param {function=} opt_callback Optional callback.\n */\nGoogleAuth.prototype.fromJSON = function(json, opt_callback) {\n  var that = this;\n  var client;\n  if (!json) {\n    callback(opt_callback, new Error(\n      'Must pass in a JSON object containing the Google auth settings.'));\n    return;\n  }\n  if (json.type === 'authorized_user') {\n    client = new that.UserRefreshClient();\n  } else {\n    client = new that.JWTClient();\n  }\n  client.fromJSON(json, function(err) {\n    if (err) {\n      callback(opt_callback, err);\n    } else {\n      callback(opt_callback, null, client);\n    }\n  });\n};\n\n/**\n * Create a credentials instance using the given input stream.\n * @param {object=} stream The input stream.\n * @param {function=} opt_callback Optional callback.\n */\nGoogleAuth.prototype.fromStream = function(stream, opt_callback) {\n  var that = this;\n  if (!stream) {\n    process.nextTick(function() {\n      callback(opt_callback, new Error(\n          'Must pass in a stream containing the Google auth settings.'));\n    });\n    return;\n  }\n  var s = '';\n  stream.setEncoding('utf8');\n  stream.on('data', function (chunk) {\n    s += chunk;\n  });\n  stream.on('end', function () {\n    try {\n      var data = JSON.parse(s);\n      that.fromJSON(data, opt_callback);\n    } catch (err) {\n      callback(opt_callback, err);\n    }\n  });\n};\n\n/**\n * Determines whether the current operating system is Windows.\n * @api private\n * */\nGoogleAuth.prototype._isWindows = function() {\n  var sys = this._osPlatform();\n  if (sys && sys.length >= 3) {\n    if (sys.substring(0, 3).toLowerCase() === 'win') {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Creates a file stream. Allows mocking.\n * @api private\n * */\nGoogleAuth.prototype._createReadStream = function(filePath) {\n  return fs.createReadStream(filePath);\n};\n\n/**\n * Gets the value of the environment variable with the given name. Allows mocking.\n * @api private\n * */\nGoogleAuth.prototype._getEnv = function(name) {\n  return process.env[name];\n};\n\n/**\n * Gets the current operating system platform. Allows mocking.\n * @api private\n * */\nGoogleAuth.prototype._osPlatform = function() {\n  return os.platform();\n};\n\n/**\n * Determines whether a file exists. Allows mocking.\n * @api private\n * */\nGoogleAuth.prototype._fileExists = function(filePath) {\n  return fs.existsSync(filePath);\n};\n\n/**\n * Joins two parts of a path. Allows mocking.\n * @api private\n * */\nGoogleAuth.prototype._pathJoin = function(item1, item2) {\n  return path.join(item1, item2);\n};\n\n/**\n * Allows mocking of the path to a well-known file.\n * @api private\n * */\nGoogleAuth.prototype._mockWellKnownFilePath = function(filePath) {\n  return filePath;\n};\n\n/**\n * Export GoogleAuth.\n */\nmodule.exports = GoogleAuth;\n","/home/travis/build/npmtest/node-npmtest-google-auth-library/node_modules/google-auth-library/lib/auth/jwtclient.js":"/**\n * Copyright 2013 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nvar Auth2Client = require('./oauth2client.js');\nvar gToken = require('gtoken');\nvar JWTAccess = require('./jwtaccess.js');\nvar noop = require('lodash.noop');\nvar util = require('util');\n\n\n/**\n * JWT service account credentials.\n *\n * Retrieve access token using gtoken.\n *\n * @param {string=} email service account email address.\n * @param {string=} keyFile path to private key file.\n * @param {string=} key value of key\n * @param {(string|array)=} scopes list of requested scopes or a single scope.\n * @param {string=} subject impersonated account's email address.\n * @constructor\n */\nfunction JWT(email, keyFile, key, scopes, subject) {\n  JWT.super_.call(this);\n  this.email = email;\n  this.keyFile = keyFile;\n  this.key = key;\n  this.scopes = scopes;\n  this.subject = subject;\n  this.gToken = gToken;\n\n  this.credentials = {\n    refresh_token: 'jwt-placeholder',\n    expiry_date: 1\n  };\n}\n\n/**\n * Inherit from Auth2Client.\n */\nutil.inherits(JWT, Auth2Client);\n\n/**\n * Creates a copy of the credential with the specified scopes.\n * @param {(string|array)=} scopes List of requested scopes or a single scope.\n * @return {object} The cloned instance.\n */\nJWT.prototype.createScoped = function(scopes) {\n  return new JWT(this.email, this.keyFile, this.key, scopes, this.subject);\n};\n\n/**\n * Obtains the metadata to be sent with the request.\n *\n * @param {string} opt_uri the URI being authorized.\n * @param {function} metadataCb\n */\nJWT.prototype.getRequestMetadata = function(opt_uri, metadataCb) {\n  if (this.createScopedRequired() && opt_uri) {\n    // no scopes have been set, but a uri has been provided.  Use JWTAccess credentials.\n    var alt = new JWTAccess(this.email, this.key);\n    return alt.getRequestMetadata(opt_uri, metadataCb);\n  } else {\n    return JWT.super_.prototype.getRequestMetadata.call(\n        this, opt_uri, metadataCb);\n  }\n};\n\n/**\n * Indicates whether the credential requires scopes to be created by calling createdScoped before\n * use.\n * @return {boolean} false if createScoped does not need to be called.\n */\nJWT.prototype.createScopedRequired = function() {\n  // If scopes is null, always return true.\n  if (this.scopes) {\n    // For arrays, check the array length.\n    if (this.scopes instanceof Array) {\n      return this.scopes.length === 0;\n    }\n\n    // For others, convert to a string and check the length.\n    return String(this.scopes).length === 0;\n  }\n\n  return true;\n};\n\n/**\n * Get the initial access token using gToken.\n * @param {function=} opt_callback Optional callback.\n */\nJWT.prototype.authorize = function(opt_callback) {\n  var that = this;\n  var done = opt_callback || noop;\n\n  that.refreshToken_(null, function(err, result) {\n    if (!err) {\n      that.credentials = result;\n      that.credentials.refresh_token = 'jwt-placeholder';\n      that.key = that.gtoken.key;\n      that.email = that.gtoken.iss;\n    }\n    done(err, result);\n  });\n};\n\n\n/**\n * Refreshes the access token.\n * @param {object=} ignored_\n * @param {function=} opt_callback Optional callback.\n * @private\n */\nJWT.prototype.refreshToken_ = function(ignored_, opt_callback) {\n  var done = opt_callback || noop;\n\n  return this._createGToken(function(err, gToken) {\n    if (err) {\n      return done(err);\n    } else {\n      return gToken.getToken(function (err, token) {\n        return done(err, {\n          access_token: token,\n          token_type: 'Bearer',\n          expiry_date: gToken.expires_at\n        });\n      });\n    }\n  });\n};\n\n\n/**\n * Create a JWT credentials instance using the given input options.\n * @param {object=} json The input object.\n * @param {function=} opt_callback Optional callback.\n */\nJWT.prototype.fromJSON = function(json, opt_callback) {\n  var that = this;\n  var done = opt_callback || noop;\n  if (!json) {\n    done(new Error(\n      'Must pass in a JSON object containing the service account auth settings.'));\n    return;\n  }\n  if (!json.client_email) {\n    done(new Error(\n      'The incoming JSON object does not contain a client_email field'));\n    return;\n  }\n  if (!json.private_key) {\n    done(new Error(\n      'The incoming JSON object does not contain a private_key field'));\n    return;\n  }\n  // Extract the relevant information from the json key file.\n  that.email = json.client_email;\n  that.key = json.private_key;\n  that.projectId = json.project_id;\n  done();\n};\n\n/**\n * Create a JWT credentials instance using the given input stream.\n * @param {object=} stream The input stream.\n * @param {function=} opt_callback Optional callback.\n */\nJWT.prototype.fromStream = function(stream, opt_callback) {\n  var that = this;\n  var done = opt_callback || noop;\n\n  if (!stream) {\n    process.nextTick(function() {\n      done(\n        new Error('Must pass in a stream containing the service account auth settings.'));\n    });\n    return;\n  }\n  var s = '';\n  stream.setEncoding('utf8');\n  stream.on('data', function (chunk) {\n    s += chunk;\n  });\n  stream.on('end', function () {\n    try {\n      var data = JSON.parse(s);\n      that.fromJSON(data, opt_callback);\n    } catch (err) {\n      done(err);\n    }\n  });\n};\n\n/**\n * Creates the gToken instance if it has not been created already.\n * @param {function=} callback Callback.\n * @private\n */\nJWT.prototype._createGToken = function(callback) {\n  if (this.gtoken) {\n    return callback(null, this.gtoken);\n  } else {\n    this.gtoken = this.gToken({\n      iss: this.email,\n      sub: this.subject,\n      scope: this.scopes,\n      keyFile: this.keyFile,\n      key: this.key\n    });\n    return callback(null, this.gtoken);\n  }\n};\n\n/**\n * Export JWT.\n */\nmodule.exports = JWT;\n","/home/travis/build/npmtest/node-npmtest-google-auth-library/node_modules/google-auth-library/lib/auth/oauth2client.js":"/**\n * Copyright 2012 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nvar AuthClient = require('./authclient.js');\nvar LoginTicket = require('./loginticket.js');\nvar noop = require('lodash.noop');\nvar PemVerifier = require('./../pemverifier.js');\nvar querystring = require('querystring');\nvar util = require('util');\n\nvar certificateCache = null;\nvar certificateExpiry = null;\n\n/**\n * Handles OAuth2 flow for Google APIs.\n *\n * @param {string} clientId The authentication client ID.\n * @param {string} clientSecret The authentication client secret.\n * @param {string} redirectUri The URI to redirect to after completing the auth request.\n * @param {Object} opt_opts optional options for overriding the given parameters.\n * @constructor\n */\nfunction OAuth2Client(clientId, clientSecret, redirectUri, opt_opts) {\n  OAuth2Client.super_.call(this);\n\n  this.clientId_ = clientId;\n  this.clientSecret_ = clientSecret;\n  this.redirectUri_ = redirectUri;\n  this.opts = opt_opts || {};\n  this.credentials = {};\n}\n\n/**\n * Inherit from AuthClient.\n */\nutil.inherits(OAuth2Client, AuthClient);\n\n/**\n * The base URL for auth endpoints.\n * @const\n * @private\n */\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n  'https://accounts.google.com/o/oauth2/auth';\n\n/**\n * The base endpoint for token retrieval.\n * @const\n * @private\n */\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ =\n  'https://accounts.google.com/o/oauth2/token';\n\n/**\n * The base endpoint to revoke tokens.\n * @const\n * @private\n */\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ =\n  'https://accounts.google.com/o/oauth2/revoke';\n\n/**\n * Google Sign on certificates.\n * @const\n * @private\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n  'https://www.googleapis.com/oauth2/v1/certs';\n\n/**\n * Clock skew - five minutes in seconds\n * @const\n * @private\n */\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n\n/**\n * Max Token Lifetime is one day in seconds\n * @const\n * @private\n */\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n/**\n * The allowed oauth token issuers.\n * @const\n * @private\n */\nOAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];\n\n/**\n * Generates URL for consent page landing.\n * @param {object=} opt_opts Options.\n * @return {string} URL to consent page.\n */\nOAuth2Client.prototype.generateAuthUrl = function(opt_opts) {\n  var opts = opt_opts || {};\n  opts.response_type = opts.response_type || 'code';\n  opts.client_id = opts.client_id || this.clientId_;\n  opts.redirect_uri = opts.redirect_uri || this.redirectUri_;\n\n  // Allow scopes to be passed either as array or a string\n  if (opts.scope instanceof Array) {\n    opts.scope = opts.scope.join(' ');\n  }\n\n  var rootUrl = this.opts.authBaseUrl ||\n    OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n\n  return rootUrl + '?' + querystring.stringify(opts);\n};\n\n/**\n * Gets the access token for the given code.\n * @param {string} code The authorization code.\n * @param {function=} opt_callback Optional callback fn.\n */\nOAuth2Client.prototype.getToken = function(code, opt_callback) {\n  var uri = this.opts.tokenUrl || OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n  var values = {\n    code: code,\n    client_id: this.clientId_,\n    client_secret: this.clientSecret_,\n    redirect_uri: this.redirectUri_,\n    grant_type: 'authorization_code'\n  };\n\n  this.transporter.request({\n    method: 'POST',\n    uri: uri,\n    form: values,\n    json: true\n  }, function(err, tokens, response) {\n    if (!err && tokens && tokens.expires_in) {\n      tokens.expiry_date = ((new Date()).getTime() + (tokens.expires_in * 1000));\n      delete tokens.expires_in;\n    }\n    var done = opt_callback || noop;\n    done(err, tokens, response);\n  });\n};\n\n/**\n * Refreshes the access token.\n * @param {string} refresh_token Existing refresh token.\n * @param {function=} opt_callback Optional callback.\n * @private\n */\nOAuth2Client.prototype.refreshToken_ = function(refresh_token, opt_callback) {\n  var uri = this.opts.tokenUrl || OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n  var values = {\n    refresh_token: refresh_token,\n    client_id: this.clientId_,\n    client_secret: this.clientSecret_,\n    grant_type: 'refresh_token'\n  };\n\n  // request for new token\n  return this.transporter.request({\n    method: 'POST',\n    uri: uri,\n    form: values,\n    json: true\n  }, function(err, tokens, response) {\n    if (!err && tokens && tokens.expires_in) {\n      tokens.expiry_date = ((new Date()).getTime() + (tokens.expires_in * 1000));\n      delete tokens.expires_in;\n    }\n    var done = opt_callback || noop;\n    done(err, tokens, response);\n  });\n};\n\n/**\n * Retrieves the access token using refresh token\n *\n * @deprecated use getRequestMetadata instead.\n * @param {function} callback callback\n */\nOAuth2Client.prototype.refreshAccessToken = function(callback) {\n  var that = this;\n\n  if (!this.credentials.refresh_token) {\n    callback(new Error('No refresh token is set.'), null);\n    return;\n  }\n\n  this.refreshToken_(this.credentials.refresh_token, function(err, result, response) {\n    if (err) {\n      callback(err, null, response);\n    } else {\n      var tokens = result;\n      tokens.refresh_token = that.credentials.refresh_token;\n      that.credentials = tokens;\n      callback(null, that.credentials, response);\n    }\n  });\n};\n\n/**\n * Get a non-expired access token, after refreshing if necessary\n *\n * @param {function} callback Callback to call with the access token\n */\nOAuth2Client.prototype.getAccessToken = function(callback) {\n  var credentials = this.credentials;\n  var expiryDate = credentials.expiry_date;\n\n  // if no expiry time, assume it's not expired\n  var isTokenExpired = expiryDate ? expiryDate <= (new Date()).getTime() : false;\n\n  if (!credentials.access_token && !credentials.refresh_token) {\n    return callback(new Error('No access or refresh token is set.'), null);\n  }\n\n  var shouldRefresh = !credentials.access_token || isTokenExpired;\n  if (shouldRefresh && credentials.refresh_token) {\n    if (!this.credentials.refresh_token) {\n      return callback(new Error('No refresh token is set.'), null);\n    }\n\n    this.refreshAccessToken(function(err, tokens, response) {\n      if (err) {\n        return callback(err, null, response);\n      }\n      if (!tokens || (tokens && !tokens.access_token)) {\n        return callback(new Error('Could not refresh access token.'), null, response);\n      }\n      return callback(null, tokens.access_token, response);\n    });\n  } else {\n    return callback(null, credentials.access_token, null);\n  }\n};\n\n/**\n * getRequestMetadata obtains auth metadata to be used by requests.\n *\n * getRequestMetadata is the main authentication interface.  It takes an\n * optional uri which when present is the endpoint being accessed, and a\n * callback func(err, metadata_obj, response) where metadata_obj contains\n * authorization metadata fields and response is an optional response object.\n *\n * In OAuth2Client, metadata_obj has the form.\n *\n * {Authorization: 'Bearer <access_token_value>'}\n *\n * @param {string} opt_uri the Uri being authorized\n * @param {function} metadataCb the func described above\n */\nOAuth2Client.prototype.getRequestMetadata = function(opt_uri, metadataCb) {\n  var that = this;\n  var thisCreds = this.credentials;\n\n  if (!thisCreds.access_token && !thisCreds.refresh_token) {\n    return metadataCb(new Error('No access or refresh token is set.'), null);\n  }\n\n  // if no expiry time, assume it's not expired\n  var expiryDate = thisCreds.expiry_date;\n  var isTokenExpired = expiryDate ? expiryDate <= (new Date()).getTime() : false;\n\n  if (thisCreds.access_token && !isTokenExpired) {\n    thisCreds.token_type = thisCreds.token_type || 'Bearer';\n    var headers = {'Authorization': thisCreds.token_type + ' ' + thisCreds.access_token };\n    return metadataCb(null, headers , null);\n  }\n\n  return this.refreshToken_(thisCreds.refresh_token, function(err, tokens, response) {\n    if (err) {\n      return metadataCb(err, null, response);\n    } else {\n      if (!tokens || (tokens && !tokens.access_token)) {\n        return metadataCb(new Error('Could not refresh access token.'), null, response);\n      }\n\n      var credentials = that.credentials;\n      credentials.token_type = credentials.token_type || 'Bearer';\n      tokens.refresh_token = credentials.refresh_token;\n      that.credentials = tokens;\n      var headers = {'Authorization': credentials.token_type + ' ' + tokens.access_token };\n      return metadataCb(err, headers , response);\n    }\n  });\n};\n\n/**\n * Revokes the access given to token.\n * @param {string} token The existing token to be revoked.\n * @param {function=} opt_callback Optional callback fn.\n */\nOAuth2Client.prototype.revokeToken = function(token, opt_callback) {\n  this.transporter.request({\n    uri: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ +\n      '?' + querystring.stringify({ token: token }),\n    json: true\n  }, opt_callback);\n};\n\n/**\n * Revokes access token and clears the credentials object\n * @param  {Function=} callback callback\n */\nOAuth2Client.prototype.revokeCredentials = function(callback) {\n  var token = this.credentials.access_token;\n  this.credentials = {};\n  if (token) {\n    this.revokeToken(token, callback);\n  } else {\n    callback(new Error('No access token to revoke.'), null);\n  }\n};\n\n/**\n * Provides a request implementation with OAuth 2.0 flow.\n * If credentials have a refresh_token, in cases of HTTP\n * 401 and 403 responses, it automatically asks for a new\n * access token and replays the unsuccessful request.\n * @param {object} opts Request options.\n * @param {function} callback callback.\n * @return {Request} Request object\n */\nOAuth2Client.prototype.request = function(opts, callback) {\n  /* jshint latedef:false */\n  var that = this;\n\n  // Callbacks will close over this to ensure that we only retry once\n  var retry = true;\n\n  // Hook the callback routine to call the _postRequest method.\n  var postRequestCb = function(err, body, resp) {\n    var statusCode = resp && resp.statusCode;\n    // Automatically retry 401 and 403 responses\n    // if err is set and is unrelated to response\n    // then getting credentials failed, and retrying won't help\n    if (retry && (statusCode === 401 || statusCode === 403) &&\n        (!err || err.code === statusCode)) {\n      /* It only makes sense to retry once, because the retry is intended to\n       * handle expiration-related failures. If refreshing the token does not\n       * fix the failure, then refreshing again probably won't help */\n      retry = false;\n      // Force token refresh\n      that.refreshAccessToken(function() {\n        that.getRequestMetadata(unusedUri, authCb);\n      });\n    } else {\n      that._postRequest(err, body, resp, callback);\n    }\n  };\n\n  var authCb = function(err, headers, response) {\n    if (err) {\n      postRequestCb(err, null, response);\n    } else {\n      if (headers) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = headers.Authorization;\n      }\n      return that._makeRequest(opts, postRequestCb);\n    }\n  };\n\n  var unusedUri = null;\n  return this.getRequestMetadata(unusedUri, authCb);\n};\n\n/**\n * Makes a request without paying attention to refreshing or anything\n * Assumes that all credentials are set correctly.\n * @param  {object}   opts     Options for request\n * @param  {Function} callback callback function\n * @return {Request}           The request object created\n */\nOAuth2Client.prototype._makeRequest = function(opts, callback) {\n  return this.transporter.request(opts, callback);\n};\n\n/**\n * Allows inheriting classes to inspect and alter the request result.\n * @param {object} err Error result.\n * @param {object} result The result.\n * @param {object} result The HTTP response.\n * @param {Function} callback The callback.\n * @private\n */\nOAuth2Client.prototype._postRequest = function(err, result, response, callback) {\n  callback(err, result, response);\n};\n\n/**\n * Verify id token is token by checking the certs and audience\n * @param {string} idToken ID Token.\n * @param {(string|Array.<string>)} audience The audience to verify against the ID Token\n * @param {function=} callback Callback supplying GoogleLogin if successful\n */\nOAuth2Client.prototype.verifyIdToken = function(idToken, audience, callback) {\n  if (!idToken || !callback) {\n    throw new Error('The verifyIdToken method requires both ' +\n      'an ID Token and a callback method');\n  }\n\n  this.getFederatedSignonCerts(function(err, certs) {\n    if (err) {\n      callback(err, null);\n    }\n    var login;\n    try {\n      login = this.verifySignedJwtWithCerts(idToken, certs, audience,\n        OAuth2Client.ISSUERS_);\n    } catch (err) {\n      callback(err);\n      return;\n    }\n\n    callback(null, login);\n  }.bind(this));\n};\n\n/**\n * Gets federated sign-on certificates to use for verifying identity tokens.\n * Returns certs as array structure, where keys are key ids, and values\n * are PEM encoded certificates.\n * @param {function=} callback Callback supplying the certificates\n */\nOAuth2Client.prototype.getFederatedSignonCerts = function(callback) {\n  var nowTime = (new Date()).getTime();\n  if (certificateExpiry && (nowTime < certificateExpiry.getTime())) {\n    callback(null, certificateCache);\n    return;\n  }\n\n  this.transporter.request({\n    method: 'GET',\n    uri: OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_,\n    json: true\n  }, function(err, body, response) {\n    if (err) {\n      callback('Failed to retrieve verification certificates: ' + err, null, response);\n      return;\n    }\n\n    var cacheControl = response.headers['cache-control'];\n    var cacheAge = -1;\n    if (cacheControl) {\n      var pattern = new RegExp('max-age=([0-9]*)');\n      var regexResult = pattern.exec(cacheControl);\n      if (regexResult.length === 2) {\n        // Cache results with max-age (in seconds)\n        cacheAge = regexResult[1] * 1000; // milliseconds\n      }\n    }\n\n    var now = new Date();\n    certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n    certificateCache = body;\n    callback(null, body, response);\n  });\n};\n\n/**\n * Verify the id token is signed with the correct certificate\n * and is from the correct audience.\n * @param {string} jwt The jwt to verify (The ID Token in this case).\n * @param {array} certs The array of certs to test the jwt against.\n * @param {(string|Array.<string>)} requiredAudience The audience to test the jwt against.\n * @param {array} issuers The allowed issuers of the jwt (Optional).\n * @param {string} maxExpiry The max expiry the certificate can be (Optional).\n * @return {LoginTicket} Returns a LoginTicket on verification.\n */\nOAuth2Client.prototype.verifySignedJwtWithCerts =\n  function(jwt, certs, requiredAudience, issuers, maxExpiry) {\n\n    if (!maxExpiry) {\n      maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n    }\n\n    var segments = jwt.split('.');\n    if (segments.length !== 3) {\n      throw new Error('Wrong number of segments in token: ' + jwt);\n    }\n    var signed = segments[0] + '.' + segments[1];\n\n    var signature = segments[2];\n\n    var envelope, payload;\n    try {\n      envelope = JSON.parse(this.decodeBase64(segments[0]));\n    } catch (err) { }\n\n    if (!envelope) {\n      throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n    }\n\n    try {\n      payload = JSON.parse(this.decodeBase64(segments[1]));\n    } catch (err) { }\n    if (!payload) {\n      throw new Error('Can\\'t parse token payload: ' + segments[1]);\n    }\n\n    if (!certs.hasOwnProperty(envelope.kid)) {\n      // If this is not present, then there's no reason to attempt verification\n      throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n    }\n    var pem = certs[envelope.kid];\n    var pemVerifier = new PemVerifier();\n    var verified = pemVerifier.verify(pem, signed, signature, 'base64');\n\n    if (!verified) {\n      throw new Error('Invalid token signature: ' + jwt);\n    }\n\n    if (!payload.iat) {\n      throw new Error('No issue time in token: ' + JSON.stringify(payload));\n    }\n\n    if (!payload.exp) {\n      throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n    }\n\n    var iat = parseInt(payload.iat, 10);\n    var exp = parseInt(payload.exp, 10);\n    var now = new Date().getTime() / 1000;\n\n    if (exp >= now + maxExpiry) {\n      throw new Error('Expiration time too far in future: ' +\n        JSON.stringify(payload));\n    }\n\n    var earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    var latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now < earliest) {\n      throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' +\n        JSON.stringify(payload));\n    }\n\n    if (now > latest) {\n      throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' +\n        JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss) < 0) {\n      throw new Error('Invalid issuer, expected one of [' + issuers +\n          '], but got ' + payload.iss);\n    }\n\n    // Check the audience matches if we have one\n    if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n      var aud = payload.aud;\n      var audVerified = false;\n      //If the requiredAudience is an array, check if it contains token audience\n      if(requiredAudience.constructor === Array)\n      {\n          audVerified = (requiredAudience.indexOf(aud) > -1);\n      }\n      else{\n          audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n         throw new Error('Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n\n    return new LoginTicket(envelope, payload);\n  };\n\n/**\n * This is a utils method to decode a base64 string\n * @param {string} b64String The string to base64 decode\n * @return {string} The decoded string\n */\nOAuth2Client.prototype.decodeBase64 = function(b64String) {\n  var buffer = new Buffer(b64String, 'base64');\n  return buffer.toString('utf8');\n};\n\n/**\n * Export OAuth2Client.\n */\nmodule.exports = OAuth2Client;\n","/home/travis/build/npmtest/node-npmtest-google-auth-library/node_modules/google-auth-library/lib/auth/authclient.js":"/**\n * Copyright 2012 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nvar DefaultTransporter = require('../transporters.js');\n\n/**\n * Base class for authentication clients.\n */\nfunction AuthClient() {\n  this.transporter = new DefaultTransporter();\n}\n\n/**\n * Provides an alternative request\n * implementations with auth credentials.\n */\nAuthClient.prototype.request = function() {\n  throw new Error('Not implemented yet.');\n};\n\n/**\n * Sets auth credentials.\n * @param {object} credentials Credentials.\n */\nAuthClient.prototype.setCredentials = function(credentials) {\n  this.credentials = credentials;\n};\n\n/**\n * Export AuthClient.\n */\nmodule.exports = AuthClient;\n","/home/travis/build/npmtest/node-npmtest-google-auth-library/node_modules/google-auth-library/lib/transporters.js":"/**\n * Copyright 2012 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nvar request = require('request'),\n  pkg = require('../package.json');\n\n/**\n * Default transporter constructor.\n * Wraps request and callback functions.\n */\nfunction DefaultTransporter() {}\n\n/**\n * Default user agent.\n */\nDefaultTransporter.prototype.USER_AGENT =\n  'google-api-nodejs-client/' + pkg.version;\n\n/**\n * Configures request options before making a request.\n * @param {object} opts Options to configure.\n * @return {object} Configured options.\n */\nDefaultTransporter.prototype.configure = function(opts) {\n  // set transporter user agent\n  opts.headers = opts.headers || {};\n  if (!opts.headers['User-Agent']) {\n    opts.headers['User-Agent'] = this.USER_AGENT;\n  } else if (opts.headers['User-Agent'].indexOf(this.USER_AGENT) === -1) {\n    opts.headers['User-Agent'] = opts.headers['User-Agent'] + ' ' + this.USER_AGENT;\n  }\n  return opts;\n};\n\n/**\n * Makes a request with given options and invokes callback.\n * @param {object} opts Options.\n * @param {Function=} opt_callback Optional callback.\n * @return {Request} Request object\n */\nDefaultTransporter.prototype.request = function(opts, opt_callback) {\n  opts = this.configure(opts);\n  return request(opts.uri || opts.url, opts, this.wrapCallback_(opt_callback));\n};\n\n/**\n * Wraps the response callback.\n * @param {Function=} opt_callback Optional callback.\n * @return {Function} Wrapped callback function.\n * @private\n */\nDefaultTransporter.prototype.wrapCallback_ = function(opt_callback) {\n  return function(err, res, body) {\n    if (err || !body) {\n      return opt_callback && opt_callback(err, body, res);\n    }\n    // Only and only application/json responses should\n    // be decoded back to JSON, but there are cases API back-ends\n    // responds without proper content-type.\n    try {\n      body = JSON.parse(body);\n    } catch (err) { /* no op */ }\n\n    if (body && body.error && res.statusCode !== 200) {\n      if (typeof body.error === 'string') {\n        err = new Error(body.error);\n        err.code = res.statusCode;\n\n      } else if (Array.isArray(body.error.errors)) {\n        err = new Error(body.error.errors.map(\n                         function(err) { return err.message; }\n                       ).join('\\n'));\n        err.code = body.error.code;\n        err.errors = body.error.errors;\n\n      } else {\n        err = new Error(body.error.message);\n        err.code = body.error.code || res.statusCode;\n      }\n\n      body = null;\n\n    } else if (res.statusCode >= 500) {\n      // Consider all '500 responses' errors.\n      err = new Error(body);\n      err.code = res.statusCode;\n      body = null;\n    }\n\n    if (opt_callback) {\n      opt_callback(err, body, res);\n    }\n  };\n};\n\n/**\n * Exports DefaultTransporter.\n */\nmodule.exports = DefaultTransporter;\n","/home/travis/build/npmtest/node-npmtest-google-auth-library/node_modules/google-auth-library/lib/pemverifier.js":"/**\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nvar crypto = require('crypto');\n\nfunction PemVerifier() {\n  this.verify = function(pubkey, data, signature, encoding) {\n    var verifier = crypto.createVerify('sha256');\n    verifier.update(data);\n    return verifier.verify(pubkey, signature, encoding);\n  };\n}\n\n/**\n * Export PemVerifier.\n */\nmodule.exports = PemVerifier;\n","/home/travis/build/npmtest/node-npmtest-google-auth-library/node_modules/google-auth-library/lib/utils.js":"/**\n * Copyright 2012 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Export extend\n * @type {Object}\n */\nmodule.exports = {\n  /**\n   * Copy key/values to obj from all other objects passed in\n   *\n   * @param {object} a the destination object.\n   * @return {object} the destination object.\n   */\n  extend: function(obj) {\n    var source, prop;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n      source = arguments[i];\n      for (prop in source) {\n        if (source.hasOwnProperty(prop)) {\n          obj[prop] = source[prop];\n        }\n      }\n    }\n    return obj;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-google-auth-library/node_modules/google-auth-library/lib/auth/computeclient.js":"/**\n * Copyright 2013 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nvar Auth2Client = require('./oauth2client.js');\nvar util = require('util');\n\n/**\n * Google Compute Engine metadata server token endpoint.\n * @private\n */\nCompute.GOOGLE_OAUTH2_TOKEN_URL_ =\n  'http://metadata.google.internal/computeMetadata/v1beta1/instance/service-accounts/default/token';\n\n/**\n * Google Compute Engine service account credentials.\n *\n * Retrieve access token from the metadata server.\n * See: https://developers.google.com/compute/docs/authentication\n * @constructor@constructor\n */\nfunction Compute() {\n  Compute.super_.call(this);\n  // Start with an expired refresh token, which will automatically be refreshed\n  // before the first API call is made.\n  this.credentials = {\n    refresh_token: 'compute-placeholder',\n    expiry_date: 1\n  };\n\n  // Hook the post request method so we can provide better error messages.\n  this._postRequest = this._injectErrorMessage;\n}\n\n/**\n * Inherit from Auth2Client.\n */\nutil.inherits(Compute, Auth2Client);\n\n/**\n * Indicates whether the credential requires scopes to be created by calling createdScoped before\n * use.\n * @return {object} The cloned instance.\n */\nCompute.prototype.createScopedRequired = function() {\n  // On compute engine, scopes are specified at the compute instance's creation time,\n  // and cannot be changed. For this reason, always return false.\n  return false;\n};\n\n/**\n * Refreshes the access token.\n * @param {object=} ignored_\n * @param {function=} opt_callback Optional callback.\n * @private\n */\nCompute.prototype.refreshToken_ = function(ignored_, opt_callback) {\n  var uri = this.opts.tokenUrl || Compute.GOOGLE_OAUTH2_TOKEN_URL_;\n  // request for new token\n  this.transporter.request({\n    method: 'GET',\n    uri: uri,\n    json: true\n  }, function(err, tokens, response) {\n    if (!err && tokens && tokens.expires_in) {\n      tokens.expiry_date = ((new Date()).getTime() + (tokens.expires_in * 1000));\n      delete tokens.expires_in;\n    }\n\n    if (opt_callback) {\n      opt_callback(err, tokens, response);\n    }\n  });\n};\n\n/**\n * Inserts a helpful error message guiding the user toward fixing common auth issues.\n * @param {object} err Error result.\n * @param {object} result The result.\n * @param {object} response The HTTP response.\n * @param {Function} callback The callback.\n * @private\n */\nCompute.prototype._injectErrorMessage = function(err, result, response, callback) {\n  if (response && response.statusCode) {\n    var helpfulMessage = null;\n    if (response.statusCode === 403) {\n      helpfulMessage = 'A Forbidden error was returned while attempting to retrieve an access ' +\n        'token for the Compute Engine built-in service account. This may be because the Compute ' +\n        'Engine instance does not have the correct permission scopes specified.';\n    } else if (response.statusCode === 404) {\n      helpfulMessage = 'A Not Found error was returned while attempting to retrieve an access' +\n        'token for the Compute Engine built-in service account. This may be because the Compute ' +\n        'Engine instance does not have any permission scopes specified.';\n    }\n    if (helpfulMessage) {\n      if (err && err.message) {\n        helpfulMessage += ' ' + err.message;\n      }\n\n      if (err) {\n        err.message = helpfulMessage;\n      } else {\n        err = new Error(helpfulMessage);\n        err.code = response.statusCode;\n      }\n    }\n  }\n  callback(err, result, response);\n};\n\n/**\n * Export Compute.\n */\nmodule.exports = Compute;\n","/home/travis/build/npmtest/node-npmtest-google-auth-library/node_modules/google-auth-library/lib/auth/iam.js":"/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * IAM credentials.\n *\n * @param {string=} selector the iam authority selector\n * @param {string=} token the token\n * @constructor\n */\nfunction IAMAuth(selector, token) {\n  this.selector = selector;\n  this.token = token;\n}\n\n/**\n * Indicates whether the credential requires scopes to be created by calling\n * createdScoped before use.\n *\n * @return {boolean} always false\n */\nIAMAuth.prototype.createScopedRequired = function() {\n  // IAM authorization does not use scopes.\n  return false;\n};\n\n/**\n * Pass the selector and token to the metadataFn callback.\n *\n * @param {string} unused_uri_ is required of the credentials interface\n * @param {function} metadataFn a callback invoked with object\n *                   containing request metadata.\n */\nIAMAuth.prototype.getRequestMetadata = function(unused_uri_, metadataFn) {\n  metadataFn(null, {\n    'x-goog-iam-authority-selector': this.selector,\n    'x-goog-iam-authorization-token': this.token\n  });\n};\n\n/**\n * Export IAMAuth.\n */\nmodule.exports = IAMAuth;\n","/home/travis/build/npmtest/node-npmtest-google-auth-library/node_modules/google-auth-library/lib/auth/jwtaccess.js":"/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nvar jws = require('jws');\nvar noop = require('lodash.noop');\n\n/**\n * JWTAccess service account credentials.\n *\n * Create a new access token by using the credential to create a new JWT token\n * that's recognized as the access token.\n *\n * @param {string=} email the service account email address.\n * @param {string=} key the private key that will be used to sign the token.\n * @constructor\n */\nfunction JWTAccess(email, key) {\n  this.email = email;\n  this.key = key;\n}\n\n/**\n * Indicates whether the credential requires scopes to be created by calling\n * createdScoped before use.\n *\n * @return {boolean} always false\n */\nJWTAccess.prototype.createScopedRequired = function() {\n  // JWT Header authentication does not use scopes.\n  return false;\n};\n\n/**\n * Get a non-expired access token, after refreshing if necessary\n *\n * @param {string} authURI the URI being authorized\n * @param {function} metadataCb a callback invoked with the jwt\n *                   request metadata.\n */\nJWTAccess.prototype.getRequestMetadata = function(authURI, metadataCb) {\n  var iat = Math.floor(new Date().getTime() / 1000);\n  var exp = iat + 3600; // 3600 seconds = 1 hour\n\n  // The payload used for signed JWT headers has:\n  // iss == sub == <client email>\n  // aud == <the authorization uri>\n  var payload = {\n    iss: this.email,\n    sub: this.email,\n    aud: authURI,\n    exp: exp,\n    iat: iat\n  };\n  var assertion = {\n    header: {\n      alg: 'RS256',\n      typ: 'JWT'\n    },\n    payload: payload,\n    secret: this.key\n  };\n\n  // Sign the jwt and invoke metadataCb with it.\n  return this._signJWT(assertion, function(err, signedJWT) {\n    if (!err) {\n      return metadataCb(null, {'Authorization': 'Bearer ' + signedJWT});\n    } else {\n      return metadataCb(err, null);\n    }\n  });\n};\n\n/**\n * Create a JWTAccess credentials instance using the given input options.\n * @param {object=} json The input object.\n * @param {function=} opt_callback Optional callback.\n */\nJWTAccess.prototype.fromJSON = function(json, opt_callback) {\n  var that = this;\n  var done = opt_callback || noop;\n  if (!json) {\n    done(new Error(\n      'Must pass in a JSON object containing the service account auth settings.'));\n    return;\n  }\n  if (!json.client_email) {\n    done(new Error(\n      'The incoming JSON object does not contain a client_email field'));\n    return;\n  }\n  if (!json.private_key) {\n    done(new Error(\n      'The incoming JSON object does not contain a private_key field'));\n    return;\n  }\n  // Extract the relevant information from the json key file.\n  that.email = json.client_email;\n  that.key = json.private_key;\n  that.projectId = json.project_id;\n  done();\n};\n\n/**\n * Create a JWTAccess credentials instance using the given input stream.\n * @param {object=} stream The input stream.\n * @param {function=} opt_callback Optional callback.\n */\nJWTAccess.prototype.fromStream = function(stream, opt_callback) {\n  var that = this;\n  var done = opt_callback || noop;\n  if (!stream) {\n    process.nextTick(function() {\n        done(\n            new Error('Must pass in a stream containing the service account auth settings.'));\n    });\n    return;\n  }\n  var s = '';\n  stream.setEncoding('utf8');\n  stream.on('data', function (chunk) {\n    s += chunk;\n  });\n  stream.on('end', function () {\n    try {\n      var data = JSON.parse(s);\n      that.fromJSON(data, opt_callback);\n    } catch (err) {\n      done(err);\n    }\n  });\n};\n\n/**\n * Sign the JWT object, returning any errors in the callback.\n *\n * signedJwtFn is a callback function(err, signedJWT); it is called with an\n * error if there is an exception during signing.\n *\n * @param  {object}   assertion   The assertion to sign\n * @param  {Function} signedJwtFn  fn(err, signedJWT)\n */\nJWTAccess.prototype._signJWT = function(assertion, signedJwtFn) {\n  try {\n    return signedJwtFn(null, jws.sign(assertion));\n  } catch (err) {\n    return signedJwtFn(err);\n  }\n};\n\n/**\n * Export JWTAccess.\n */\nmodule.exports = JWTAccess;\n","/home/travis/build/npmtest/node-npmtest-google-auth-library/node_modules/google-auth-library/lib/auth/loginticket.js":"/**\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nvar USER_ATTR = 'sub';\n\n/**\n * Create a simple class to extract user ID from an ID Token\n *\n * @param {string} env Envelope of the jwt\n * @param {string} pay Payload of the jwt\n * @constructor\n */\nfunction LoginTicket(env, pay) {\n  var envelope = env;\n  var payload = pay;\n\n  this.getEnvelope = function() {\n    return envelope;\n  };\n\n  this.getPayload = function() {\n    return payload;\n  };\n}\n\n/**\n * Create a simple class to extract user ID from an ID Token\n *\n * @return {string} The user ID\n */\nLoginTicket.prototype.getUserId = function() {\n  var payload = this.getPayload();\n  if (payload && payload[USER_ATTR]) {\n    return payload[USER_ATTR];\n  }\n\n  return null;\n};\n\n/**\n * Returns attributes from the login ticket.  This can contain\n * various information about the user session.\n *\n * @return {Object} The envelope and payload\n */\nLoginTicket.prototype.getAttributes = function() {\n  return {\n    'envelope': this.getEnvelope(),\n    'payload': this.getPayload()\n  };\n};\n\n/**\n * Export LoginTicket.\n */\nmodule.exports = LoginTicket;\n","/home/travis/build/npmtest/node-npmtest-google-auth-library/node_modules/google-auth-library/lib/auth/refreshclient.js":"/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nvar Auth2Client = require('./oauth2client.js');\nvar util = require('util');\n\n/**\n * User Refresh Token credentials.\n *\n * @param {string} clientId The authentication client ID.\n * @param {string} clientSecret The authentication client secret.\n * @param {string} refreshToken The authentication refresh token.\n * @constructor\n */\nfunction UserRefreshClient(clientId, clientSecret, refreshToken) {\n  UserRefreshClient.super_.call(this, clientId, clientSecret);\n  // Named to avoid collision with the method refreshToken_\n  this._refreshToken = refreshToken;\n}\n\nutil.inherits(UserRefreshClient, Auth2Client);\n\n// Executes the given callback if it is not null.\nfunction callback(c, err, res) {\n  if (c) {\n    c(err, res);\n  }\n}\n\n/**\n * Refreshes the access token.\n * @param {object=} ignored_\n * @param {function=} opt_callback Optional callback.\n * @private\n */\nUserRefreshClient.prototype.refreshToken_ = function(ignored_, opt_callback) {\n  UserRefreshClient.super_.prototype.refreshToken_.call(\n      this, this._refreshToken, opt_callback);\n};\n\n/**\n * Create a UserRefreshClient credentials instance using the given input options.\n * @param {object=} json The input object.\n * @param {function=} opt_callback Optional callback.\n */\nUserRefreshClient.prototype.fromJSON = function(json, opt_callback) {\n  var that = this;\n  if (!json) {\n    callback(opt_callback, new Error(\n        'Must pass in a JSON object containing the user refresh token'));\n    return;\n  }\n  if (json.type !== 'authorized_user') {\n    callback(opt_callback, new Error(\n        'The incoming JSON object does not have the \"authorized_user\" type'));\n    return;\n  }\n  if (!json.client_id) {\n    callback(opt_callback, new Error(\n        'The incoming JSON object does not contain a client_id field'));\n    return;\n  }\n  if (!json.client_secret) {\n    callback(opt_callback, new Error(\n        'The incoming JSON object does not contain a client_secret field'));\n    return;\n  }\n  if (!json.refresh_token) {\n    callback(opt_callback, new Error(\n        'The incoming JSON object does not contain a refresh_token field'));\n    return;\n  }\n  that.clientId_ = json.client_id;\n  that.clientSecret_ = json.client_secret;\n  that._refreshToken = json.refresh_token;\n  that.credentials.refresh_token = json.refresh_token;\n  callback(opt_callback);\n};\n\n/**\n * Create a UserRefreshClient credentials instance using the given input stream.\n * @param {object=} stream The input stream.\n * @param {function=} opt_callback Optional callback.\n */\nUserRefreshClient.prototype.fromStream = function(stream, opt_callback) {\n  var that = this;\n  if (!stream) {\n    process.nextTick(function() {\n      callback(\n        opt_callback,\n        new Error('Must pass in a stream containing the user refresh token.'));\n    });\n    return;\n  }\n  var s = '';\n  stream.setEncoding('utf8');\n  stream.on('data', function (chunk) {\n    s += chunk;\n  });\n  stream.on('end', function () {\n    try {\n      var data = JSON.parse(s);\n      that.fromJSON(data, opt_callback);\n    } catch (err) {\n      callback(opt_callback, err);\n    }\n  });\n};\n\n/**\n * Export UserRefreshClient\n */\nmodule.exports = UserRefreshClient;\n"}